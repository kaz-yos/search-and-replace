* Meta-data :noexport:
# http://orgmode.org/worg/exporters/beamer/tutorial.html
#+TITLE: My Search and Replacement Strategies @@latex:\\@@ avy, swiper, multiple-cursor, ag, and wgrep
#+AUTHOR:    Kazuki Yoshida
#+EMAIL:
#+DATE:
#+DESCRIPTION:
#+KEYWORDS:
#+OPTIONS: toc:nil
#+OPTIONS: H:2
#+OPTIONS: ^:{}
#+STARTUP: beamer
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)
#+LATEX_CLASS: beamer
#+LATEX_CLASS_OPTIONS: [dvipdfmx,bigger]
#+LATEX_HEADER: %% No navigation bar
#+LATEX_HEADER: \setbeamertemplate{navigation symbols}{}
#+LATEX_HEADER: %% Page number with current/total format
#+LATEX_HEADER: \setbeamerfont{page number in head/foot}{size=\footnotesize}
#+LATEX_HEADER: \setbeamertemplate{footline}[frame number]
#+LATEX_HEADER: \setbeamertemplate{frametitle}[default][center]
#+LATEX_HEADER: %% With item labels
#+LATEX_HEADER: \setbeamertemplate{bibliography item}{\insertbiblabel}
#+LATEX_HEADER: %% Without item labels
#+LATEX_HEADER: %% \setbeamertemplate{bibliography item}{}
#+LATEX_HEADER: %% Code
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{courier}
#+LATEX_HEADER: \lstset{basicstyle=\footnotesize\ttfamily, breaklines=true, frame=single}
#+LATEX_HEADER: \usepackage[cache=false]{minted}
#+LATEX_HEADER: \usemintedstyle{emacs}

# ############################################################################ #

* Introduction
** Who Am I?

- Doctoral student at Harvard T.H. Chan School of Public Health (Epidemiology & Biostatistics).
- emacs user since 2012.
- Main use of emacs: =R= programming and \LaTeX.
- Maintainer of [[https://github.com/kaz-yos/eval-in-repl][=eval-in-repl=]] and [[https://github.com/kaz-yos/reveal-in-osx-finder][=reveal-in-osx-finder=]] on [[https://melpa.org/#/][MELPA]].
- Co-organizer of Boston Emacs Meetup since 2017.


** Packages Mentioned

- avy: https://github.com/abo-abo/avy
- swiper: https://github.com/abo-abo/swiper#swiper
- multiple-cursor: https://github.com/magnars/multiple-cursors.el
- ag: https://github.com/Wilfred/ag.el
- wgrep: https://github.com/mhayashi1120/Emacs-wgrep


** Demonstration Environment
- MacBook Air (13-inch, Mid 2012)
- macOS Sierra 10.12.6
- emacs-plus 26.0.50
=brew install emacs-plus --with-natural-title-bar --HEAD=
- Beamer slides exported via =org-beamer= and =org-mode= 9.0.9

#+ATTR_LATEX: :height 3cm :options page=1
[[./source/mac-us-english-keyboard_1024x1024.png]]


* Avy
** Title
   :PROPERTIES:
   :BEAMER_ENV: fullframe
   :END:
#+ATTR_LATEX: :width \textwidth :options page=1
[[./source/avy-avatar-1.png]]


** Screenshot
   :PROPERTIES:
   :BEAMER_ENV: fullframe
   :END:

#+ATTR_LATEX: :width \textwidth :options page=1
[[./source/avy_screenshot.png]]


** What is it?

- "Jump to things in Emacs tree-style"
- Repo: https://github.com/abo-abo/avy
- Video: https://www.youtube.com/watch?v=ziytRbASKeU
- Purpose: Move the cursor to anywhere visible by "searching".

** Example Workflow

- =Meta-x avy-goto-char= to invoke on a specified character (prompt)
- =Meta-x avy-goto-word-1= to invoke on a specified character at the word beginning (prompt)
- =Meta-x avy-goto-line= to invoke on all lines (no prompt)

I personally use a hack for =avy-goto-char= to avoid the prompt asking for a character. For example, =Meta-super-a= invokes directly =(avy-goto-char ?a)= without having to enter =a= in the prompt.

** Configuration
   :PROPERTIES:
   :BEAMER_ENV: fullframe
   :END:

   \tiny
#+BEGIN_SRC elisp :eval no
(use-package avy
  :demand
  :config
  ;; Darken background.
  (setq avy-background t)
  ;; Highlight the first decision char with `avy-lead-face-0'.
  ;; https://github.com/abo-abo/avy/wiki/defcustom#avy-highlight-first
  (setq avy-highlight-first t)
  ;; The default method of displaying the overlays.
  ;; https://github.com/abo-abo/avy/wiki/defcustom#avy-style
  (setq avy-style 'at-full)
  ;; Keys to be used. Use a-z.
  (setq avy-keys (loop for c from ?a to ?z collect c))
  ;; Time out for *-timer functions
  (setq avy-timeout-seconds 0.3)
  ;;
  ;; one-step activation https://github.com/cjohansen/.emacs.d/commit/65efe88
  (defun add-keys-to-avy (prefix c &optional mode)
    (define-key global-map
      (read-kbd-macro (concat prefix (string c)))
      `(lambda ()
         (interactive)
         (funcall (cond
                   ;; Word beginning
                   ((eq ',mode 'word)  #'avy-goto-word-1)
                   ;; Anywhere
                   (t                  #'avy-goto-char))
                  ,c))))
  ;; Assing key bindings for all characters
  ;; eg, M-s-x will activate (avy-goto-char ?x), ie, all occurrence of x
  (loop for c from ?! to ?~ do (add-keys-to-avy "M-s-" c))
  ;; eg, A-s-x will activate (avy-goto-word-1 ?x), ie, all words starting with x
  (loop for c from ?! to ?~ do (add-keys-to-avy "C-M-s-" c 'word)))
#+END_SRC


* Swiper
** Title
   :PROPERTIES:
   :BEAMER_ENV: fullframe
   :END:
#+ATTR_LATEX: :width \textwidth :options page=1
[[./source/swiper.png]]


** Screenshot
   :PROPERTIES:
   :BEAMER_ENV: fullframe
   :END:

#+ATTR_LATEX: :width \textwidth :options page=1
[[./source/swiper_screenshot.png]]


** What is it?

- "Alternative to isearch that uses ivy to show an overview of all matches"
- Repo: https://github.com/abo-abo/swiper#swiper
- Video: https://www.youtube.com/watch?v=0mwwN0S1dnQ
- Main function: =M-x swiper=
- Purpose: Within-buffer searching

** Workflow

-


** Configuration
   :PROPERTIES:
   :BEAMER_ENV: fullframe
   :END:
   \tiny
#+BEGIN_SRC elisp :eval no
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Recursive-Mini.html
(setq enable-recursive-minibuffers)

(use-package swiper
  :commands (swiper
             swiper-at-point)
  :bind (("s-s" . swiper-at-point)
         ("C-s-s" . swiper)
         ;; Add bindings to isearch-mode
         :map isearch-mode-map
         ("s-s" . swiper-from-isearch))
  :init
  ;; Newly defined
  (defun swiper-at-point ()
    "Custom function to pick up a thing at a point for swiper

If a selected region exists, it will be searched for by swiper
If there is a symbol at the current point, its textual representation is
searched. If there is no symbol, empty search box is started."
    (interactive)
    (swiper (selection-or-thing-at-point))))

(defun selection-or-thing-at-point ()
  (cond
   ;; If there is selection use it
   ((and transient-mark-mode mark-active
         (not (eq (mark) (point))))
    (buffer-substring-no-properties (mark) (point)))
   ;; Otherwise, use symbol at point or empty
   (t (format "%s"
              (or (thing-at-point 'symbol)
                  "")))))
#+END_SRC
